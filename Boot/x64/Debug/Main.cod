; Listing generated by Microsoft (R) Optimizing Compiler Version 19.38.33135.0 

include listing.inc

INCLUDELIB LIBCMTD

_DATA	SEGMENT
COMM	MemoryMapBuffer:BYTE:02800H
COMM	SystemConfiguration:BYTE:060H
COMM	EntryPoint:QWORD
_DATA	ENDS
PUBLIC	GetSystemConfiguration
PUBLIC	LoadKernel
PUBLIC	TransitToKernel
PUBLIC	Main
EXTRN	InitializeEFI:PROC
EXTRN	Assert:PROC
EXTRN	CompareGUID:PROC
EXTRN	SystemTable:QWORD
EXTRN	GraphicsOutputProtocol:QWORD
EXTRN	SimpleFileSystemProtocol:QWORD
pdata	SEGMENT
$pdata$GetSystemConfiguration DD imagerel $LN13
	DD	imagerel $LN13+492
	DD	imagerel $unwind$GetSystemConfiguration
$pdata$LoadKernel DD imagerel $LN3
	DD	imagerel $LN3+599
	DD	imagerel $unwind$LoadKernel
$pdata$TransitToKernel DD imagerel $LN5
	DD	imagerel $LN5+204
	DD	imagerel $unwind$TransitToKernel
$pdata$GetLoadAddressRange DD imagerel GetLoadAddressRange
	DD	imagerel GetLoadAddressRange+398
	DD	imagerel $unwind$GetLoadAddressRange
$pdata$LoadFileSegment DD imagerel LoadFileSegment
	DD	imagerel LoadFileSegment+598
	DD	imagerel $unwind$LoadFileSegment
$pdata$Main DD	imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$Main
pdata	ENDS
_DATA	SEGMENT
$SG7978	DB	'G', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r'
	DB	00H, 'y', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'p', 00H, 00H, 00H
	ORG $+10
$SG7982	DB	'G', 00H, 'r', 00H, 'a', 00H, 'p', 00H, 'h', 00H, 'i', 00H
	DB	'c', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 'p'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H
	DB	't', 00H, 'o', 00H, 'c', 00H, 'o', 00H, 'l', 00H, ' ', 00H, 'd'
	DB	00H, 'o', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o'
	DB	00H, 'r', 00H, 't', 00H, ' ', 00H, 'R', 00H, 'G', 00H, 'B', 00H
	DB	' ', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG7985	DB	'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'A', 00H, 'C', 00H, 'P', 00H, 'I'
	DB	00H, ' ', 00H, 'T', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H
$SG8011	DB	'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'r', 00H, 'o', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'd', 00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG8012	DB	'\', 00H, 'K', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e', 00H
	DB	'l', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H, 00H
$SG8013	DB	'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, '''', 00H, '\', 00H, 'K', 00H, 'e', 00H, 'r', 00H, 'n', 00H
	DB	'e', 00H, 'l', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, ''''
	DB	00H, 00H, 00H
	ORG $+2
$SG8014	DB	'G', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'k', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e'
	DB	00H, 'l', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG8015	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, 00H, 00H
$SG8016	DB	'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'k', 00H, 'e', 00H, 'r', 00H, 'n', 00H, 'e'
	DB	00H, 'l', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H
$SG8017	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'g', 00H, 'e', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG8018	DB	'F', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+6
$SG8029	DB	'E', 00H, 'x', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 00H, 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$GetSystemConfiguration DD 010401H
	DD	0c204H
$unwind$LoadKernel DD 020701H
	DD	0230107H
$unwind$TransitToKernel DD 010901H
	DD	08209H
$unwind$GetLoadAddressRange DD 011301H
	DD	06213H
$unwind$LoadFileSegment DD 041301H
	DD	0130113H
	DD	0600b700cH
$unwind$Main DD	010e01H
	DD	0420eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
_ImageHandle$ = 48
_SystemTable$ = 56
Main	PROC

; 16   : )	{

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 17   : 
; 18   : 	InitializeEFI(_SystemTable);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _SystemTable$[rsp]
  00013	e8 00 00 00 00	 call	 InitializeEFI

; 19   : 
; 20   : 	GetSystemConfiguration();

  00018	e8 00 00 00 00	 call	 GetSystemConfiguration

; 21   : 
; 22   : 	LoadKernel();

  0001d	e8 00 00 00 00	 call	 LoadKernel

; 23   : 
; 24   : 	TransitToKernel(_ImageHandle);

  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _ImageHandle$[rsp]
  00027	e8 00 00 00 00	 call	 TransitToKernel

; 25   : 
; 26   : 	return EFI_SUCCESS;

  0002c	33 c0		 xor	 eax, eax

; 27   : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
Main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
FileSectionHeader$ = 32
Index$ = 40
FileSection$ = 48
FileDOSHeader$ = 88
FileNTHeader$ = 96
Segment$ = 104
tv167 = 112
tv166 = 120
tv165 = 128
tv164 = 136
_FileBuffer$ = 176
_FileStartAddress$ = 184
LoadFileSegment PROC

; 194  : )	{

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 195  : 	UINTN					Index;
; 196  : 
; 197  : 	EFI_PHYSICAL_ADDRESS	Segment;
; 198  : 	DOSHeader*				FileDOSHeader = (DOSHeader*)_FileBuffer;

  00013	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  0001b	48 89 44 24 58	 mov	 QWORD PTR FileDOSHeader$[rsp], rax

; 199  : 	NTHeader*				FileNTHeader = (NTHeader*)((BYTE*)_FileBuffer + FileDOSHeader->e_lfanew);

  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR FileDOSHeader$[rsp]
  00025	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  00029	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _FileBuffer$[rsp]
  00031	48 03 c8	 add	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 89 44 24 60	 mov	 QWORD PTR FileNTHeader$[rsp], rax

; 200  : 	EFI_PHYSICAL_ADDRESS	FileSectionHeader = (EFI_PHYSICAL_ADDRESS)_FileBuffer + FileDOSHeader->e_lfanew + sizeof(NTHeader) + FileNTHeader->optionalHeader.NumberOfRvaAndSizes * sizeof(DataDirectory);

  0003c	48 8b 44 24 58	 mov	 rax, QWORD PTR FileDOSHeader$[rsp]
  00041	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  00045	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _FileBuffer$[rsp]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR FileNTHeader$[rsp]
  00058	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0005e	48 8d 84 c8 88
	00 00 00	 lea	 rax, QWORD PTR [rax+rcx*8+136]
  00066	48 89 44 24 20	 mov	 QWORD PTR FileSectionHeader$[rsp], rax

; 201  : 	Section					FileSection;
; 202  : 
; 203  : 	if ((FileSectionHeader - (EFI_PHYSICAL_ADDRESS)_FileBuffer) % 8 != 0) {

  0006b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  00078	48 2b c8	 sub	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	33 d2		 xor	 edx, edx
  00080	b9 08 00 00 00	 mov	 ecx, 8
  00085	48 f7 f1	 div	 rcx
  00088	48 8b c2	 mov	 rax, rdx
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 3b		 je	 SHORT $LN5@LoadFileSe

; 204  : 		FileSectionHeader += 8 - (FileSectionHeader - (EFI_PHYSICAL_ADDRESS)_FileBuffer) % 8;

  00090	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  00098	48 8b 4c 24 20	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  0009d	48 2b c8	 sub	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	33 d2		 xor	 edx, edx
  000a5	b9 08 00 00 00	 mov	 ecx, 8
  000aa	48 f7 f1	 div	 rcx
  000ad	48 8b c2	 mov	 rax, rdx
  000b0	b9 08 00 00 00	 mov	 ecx, 8
  000b5	48 2b c8	 sub	 rcx, rax
  000b8	48 8b c1	 mov	 rax, rcx
  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  000c0	48 03 c8	 add	 rcx, rax
  000c3	48 8b c1	 mov	 rax, rcx
  000c6	48 89 44 24 20	 mov	 QWORD PTR FileSectionHeader$[rsp], rax
$LN5@LoadFileSe:

; 205  : 	}
; 206  : 
; 207  : 	for (Index = 0; Index < FileNTHeader->fileHeader.NumberOfSections; ++Index) {

  000cb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR Index$[rsp], 0
  000d4	eb 0d		 jmp	 SHORT $LN4@LoadFileSe
$LN2@LoadFileSe:
  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR Index$[rsp]
  000db	48 ff c0	 inc	 rax
  000de	48 89 44 24 28	 mov	 QWORD PTR Index$[rsp], rax
$LN4@LoadFileSe:
  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR FileNTHeader$[rsp]
  000e8	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000ec	48 39 44 24 28	 cmp	 QWORD PTR Index$[rsp], rax
  000f1	0f 83 55 01 00
	00		 jae	 $LN3@LoadFileSe

; 208  : 		FileSection = *((Section*)FileSectionHeader + Index);

  000f7	48 6b 44 24 28
	28		 imul	 rax, QWORD PTR Index$[rsp], 40 ; 00000028H
  000fd	48 8d 4c 24 30	 lea	 rcx, QWORD PTR FileSection$[rsp]
  00102	48 8b 54 24 20	 mov	 rdx, QWORD PTR FileSectionHeader$[rsp]
  00107	48 8b f9	 mov	 rdi, rcx
  0010a	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0010e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00113	f3 a4		 rep movsb

; 209  : 		Segment = (EFI_PHYSICAL_ADDRESS)((BYTE*)_FileBuffer + FileSection.PointerToRawData);

  00115	8b 44 24 44	 mov	 eax, DWORD PTR FileSection$[rsp+20]
  00119	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _FileBuffer$[rsp]
  00121	48 03 c8	 add	 rcx, rax
  00124	48 8b c1	 mov	 rax, rcx
  00127	48 89 44 24 68	 mov	 QWORD PTR Segment$[rsp], rax

; 210  : 
; 211  : 		if (FileSection.VirtualSize > FileSection.SizeOfRawData) {

  0012c	8b 44 24 40	 mov	 eax, DWORD PTR FileSection$[rsp+16]
  00130	39 44 24 38	 cmp	 DWORD PTR FileSection$[rsp+8], eax
  00134	0f 86 83 00 00
	00		 jbe	 $LN6@LoadFileSe

; 212  : 			SystemTable->BootServices->CopyMem((VOID*)(_FileStartAddress + FileSection.VirtualAddress), (VOID*)Segment, FileSection.SizeOfRawData);

  0013a	8b 44 24 40	 mov	 eax, DWORD PTR FileSection$[rsp+16]
  0013e	8b 4c 24 3c	 mov	 ecx, DWORD PTR FileSection$[rsp+12]
  00142	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR _FileStartAddress$[rsp]
  0014a	48 03 d1	 add	 rdx, rcx
  0014d	48 8b ca	 mov	 rcx, rdx
  00150	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SystemTable
  00157	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  0015b	48 89 54 24 70	 mov	 QWORD PTR tv167[rsp], rdx
  00160	44 8b c0	 mov	 r8d, eax
  00163	48 8b 54 24 68	 mov	 rdx, QWORD PTR Segment$[rsp]
  00168	48 8b 44 24 70	 mov	 rax, QWORD PTR tv167[rsp]
  0016d	ff 90 60 01 00
	00		 call	 QWORD PTR [rax+352]

; 213  : 			SystemTable->BootServices->SetMem((VOID*)(_FileStartAddress + FileSection.VirtualAddress + FileSection.SizeOfRawData), (UINTN)FileSection.VirtualSize - FileSection.SizeOfRawData, 0);

  00173	8b 44 24 38	 mov	 eax, DWORD PTR FileSection$[rsp+8]
  00177	8b 4c 24 40	 mov	 ecx, DWORD PTR FileSection$[rsp+16]
  0017b	48 2b c1	 sub	 rax, rcx
  0017e	8b 4c 24 3c	 mov	 ecx, DWORD PTR FileSection$[rsp+12]
  00182	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR _FileStartAddress$[rsp]
  0018a	48 03 d1	 add	 rdx, rcx
  0018d	48 8b ca	 mov	 rcx, rdx
  00190	8b 54 24 40	 mov	 edx, DWORD PTR FileSection$[rsp+16]
  00194	48 03 ca	 add	 rcx, rdx
  00197	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SystemTable
  0019e	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  001a2	48 89 54 24 78	 mov	 QWORD PTR tv166[rsp], rdx
  001a7	45 33 c0	 xor	 r8d, r8d
  001aa	48 8b d0	 mov	 rdx, rax
  001ad	48 8b 44 24 78	 mov	 rax, QWORD PTR tv166[rsp]
  001b2	ff 90 68 01 00
	00		 call	 QWORD PTR [rax+360]

; 214  : 		}

  001b8	e9 8a 00 00 00	 jmp	 $LN7@LoadFileSe
$LN6@LoadFileSe:

; 215  : 		else {
; 216  : 			SystemTable->BootServices->CopyMem((VOID*)(_FileStartAddress + FileSection.VirtualAddress), (VOID*)Segment, FileSection.VirtualSize);

  001bd	8b 44 24 38	 mov	 eax, DWORD PTR FileSection$[rsp+8]
  001c1	8b 4c 24 3c	 mov	 ecx, DWORD PTR FileSection$[rsp+12]
  001c5	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR _FileStartAddress$[rsp]
  001cd	48 03 d1	 add	 rdx, rcx
  001d0	48 8b ca	 mov	 rcx, rdx
  001d3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SystemTable
  001da	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  001de	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR tv165[rsp], rdx
  001e6	44 8b c0	 mov	 r8d, eax
  001e9	48 8b 54 24 68	 mov	 rdx, QWORD PTR Segment$[rsp]
  001ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv165[rsp]
  001f6	ff 90 60 01 00
	00		 call	 QWORD PTR [rax+352]

; 217  : 			SystemTable->BootServices->SetMem((VOID*)(_FileStartAddress + FileSection.VirtualAddress + FileSection.VirtualSize), (UINTN)FileSection.SizeOfRawData - FileSection.VirtualSize, 0);

  001fc	8b 44 24 40	 mov	 eax, DWORD PTR FileSection$[rsp+16]
  00200	8b 4c 24 38	 mov	 ecx, DWORD PTR FileSection$[rsp+8]
  00204	48 2b c1	 sub	 rax, rcx
  00207	8b 4c 24 3c	 mov	 ecx, DWORD PTR FileSection$[rsp+12]
  0020b	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR _FileStartAddress$[rsp]
  00213	48 03 d1	 add	 rdx, rcx
  00216	48 8b ca	 mov	 rcx, rdx
  00219	8b 54 24 38	 mov	 edx, DWORD PTR FileSection$[rsp+8]
  0021d	48 03 ca	 add	 rcx, rdx
  00220	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR SystemTable
  00227	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  0022b	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv164[rsp], rdx
  00233	45 33 c0	 xor	 r8d, r8d
  00236	48 8b d0	 mov	 rdx, rax
  00239	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv164[rsp]
  00241	ff 90 68 01 00
	00		 call	 QWORD PTR [rax+360]
$LN7@LoadFileSe:

; 218  : 		}
; 219  : 	}

  00247	e9 8a fe ff ff	 jmp	 $LN2@LoadFileSe
$LN3@LoadFileSe:

; 220  : }

  0024c	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00253	5f		 pop	 rdi
  00254	5e		 pop	 rsi
  00255	c3		 ret	 0
LoadFileSegment ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
FileSectionHeader$ = 0
FileNTHeader$ = 8
Index$ = 16
FileSection$ = 24
FileDOSHeader$ = 32
tv136 = 40
_FileBuffer$ = 64
_Start$ = 72
_End$ = 80
GetLoadAddressRange PROC

; 168  : )	{

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 169  : 	UINTN					Index;
; 170  : 
; 171  : 	DOSHeader*				FileDOSHeader = (DOSHeader*)_FileBuffer;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR FileDOSHeader$[rsp], rax

; 172  : 	NTHeader*				FileNTHeader = (NTHeader*)((BYTE*)_FileBuffer + FileDOSHeader->e_lfanew);

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR FileDOSHeader$[rsp]
  00022	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _FileBuffer$[rsp]
  0002b	48 03 c8	 add	 rcx, rax
  0002e	48 8b c1	 mov	 rax, rcx
  00031	48 89 44 24 08	 mov	 QWORD PTR FileNTHeader$[rsp], rax

; 173  : 	EFI_PHYSICAL_ADDRESS	FileSectionHeader = (EFI_PHYSICAL_ADDRESS)_FileBuffer + FileDOSHeader->e_lfanew + sizeof(NTHeader) + FileNTHeader->optionalHeader.NumberOfRvaAndSizes * sizeof(DataDirectory);

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR FileDOSHeader$[rsp]
  0003b	0f b7 40 3c	 movzx	 eax, WORD PTR [rax+60]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _FileBuffer$[rsp]
  00044	48 03 c8	 add	 rcx, rax
  00047	48 8b c1	 mov	 rax, rcx
  0004a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR FileNTHeader$[rsp]
  0004f	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00055	48 8d 84 c8 88
	00 00 00	 lea	 rax, QWORD PTR [rax+rcx*8+136]
  0005d	48 89 04 24	 mov	 QWORD PTR FileSectionHeader$[rsp], rax

; 174  : 	Section*				FileSection;
; 175  : 
; 176  : 	if (((EFI_PHYSICAL_ADDRESS)FileSectionHeader - (EFI_PHYSICAL_ADDRESS)_FileBuffer) % 8 != 0) {

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  00066	48 8b 0c 24	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  0006a	48 2b c8	 sub	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	33 d2		 xor	 edx, edx
  00072	b9 08 00 00 00	 mov	 ecx, 8
  00077	48 f7 f1	 div	 rcx
  0007a	48 8b c2	 mov	 rax, rdx
  0007d	48 85 c0	 test	 rax, rax
  00080	74 35		 je	 SHORT $LN5@GetLoadAdd

; 177  : 		FileSectionHeader += 8 - ((EFI_PHYSICAL_ADDRESS)FileSectionHeader - (EFI_PHYSICAL_ADDRESS)_FileBuffer) % 8;

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR _FileBuffer$[rsp]
  00087	48 8b 0c 24	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  0008b	48 2b c8	 sub	 rcx, rax
  0008e	48 8b c1	 mov	 rax, rcx
  00091	33 d2		 xor	 edx, edx
  00093	b9 08 00 00 00	 mov	 ecx, 8
  00098	48 f7 f1	 div	 rcx
  0009b	48 8b c2	 mov	 rax, rdx
  0009e	b9 08 00 00 00	 mov	 ecx, 8
  000a3	48 2b c8	 sub	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 8b 0c 24	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 89 04 24	 mov	 QWORD PTR FileSectionHeader$[rsp], rax
$LN5@GetLoadAdd:

; 178  : 	}
; 179  : 
; 180  : 	*_Start = FileNTHeader->optionalHeader.ImageBase;

  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR _Start$[rsp]
  000bc	48 8b 4c 24 08	 mov	 rcx, QWORD PTR FileNTHeader$[rsp]
  000c1	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000c5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 181  : 	*_End = 0;

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR _End$[rsp]
  000cd	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 182  : 
; 183  : 	for (Index = 0; Index < FileNTHeader->fileHeader.NumberOfSections; ++Index) {

  000d4	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR Index$[rsp], 0
  000dd	eb 0d		 jmp	 SHORT $LN4@GetLoadAdd
$LN2@GetLoadAdd:
  000df	48 8b 44 24 10	 mov	 rax, QWORD PTR Index$[rsp]
  000e4	48 ff c0	 inc	 rax
  000e7	48 89 44 24 10	 mov	 QWORD PTR Index$[rsp], rax
$LN4@GetLoadAdd:
  000ec	48 8b 44 24 08	 mov	 rax, QWORD PTR FileNTHeader$[rsp]
  000f1	0f b7 40 06	 movzx	 eax, WORD PTR [rax+6]
  000f5	48 39 44 24 10	 cmp	 QWORD PTR Index$[rsp], rax
  000fa	0f 83 89 00 00
	00		 jae	 $LN3@GetLoadAdd

; 184  : 		FileSection = (Section*)(FileSectionHeader + Index * sizeof(Section));

  00100	48 6b 44 24 10
	28		 imul	 rax, QWORD PTR Index$[rsp], 40 ; 00000028H
  00106	48 8b 0c 24	 mov	 rcx, QWORD PTR FileSectionHeader$[rsp]
  0010a	48 03 c8	 add	 rcx, rax
  0010d	48 8b c1	 mov	 rax, rcx
  00110	48 89 44 24 18	 mov	 QWORD PTR FileSection$[rsp], rax

; 185  : 
; 186  : 		*_End = (*_End > FileNTHeader->optionalHeader.ImageBase + FileSection->VirtualAddress + FileSection->VirtualSize) ? *_End : FileNTHeader->optionalHeader.ImageBase + FileSection->VirtualAddress + FileSection->VirtualSize;

  00115	48 8b 44 24 18	 mov	 rax, QWORD PTR FileSection$[rsp]
  0011a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0011d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR FileNTHeader$[rsp]
  00122	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00126	48 03 c8	 add	 rcx, rax
  00129	48 8b c1	 mov	 rax, rcx
  0012c	48 8b 4c 24 18	 mov	 rcx, QWORD PTR FileSection$[rsp]
  00131	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00134	48 03 c1	 add	 rax, rcx
  00137	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _End$[rsp]
  0013c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0013f	76 0f		 jbe	 SHORT $LN7@GetLoadAdd
  00141	48 8b 44 24 50	 mov	 rax, QWORD PTR _End$[rsp]
  00146	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00149	48 89 44 24 28	 mov	 QWORD PTR tv136[rsp], rax
  0014e	eb 27		 jmp	 SHORT $LN8@GetLoadAdd
$LN7@GetLoadAdd:
  00150	48 8b 44 24 18	 mov	 rax, QWORD PTR FileSection$[rsp]
  00155	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00158	48 8b 4c 24 08	 mov	 rcx, QWORD PTR FileNTHeader$[rsp]
  0015d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00161	48 03 c8	 add	 rcx, rax
  00164	48 8b c1	 mov	 rax, rcx
  00167	48 8b 4c 24 18	 mov	 rcx, QWORD PTR FileSection$[rsp]
  0016c	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0016f	48 03 c1	 add	 rax, rcx
  00172	48 89 44 24 28	 mov	 QWORD PTR tv136[rsp], rax
$LN8@GetLoadAdd:
  00177	48 8b 44 24 50	 mov	 rax, QWORD PTR _End$[rsp]
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv136[rsp]
  00181	48 89 08	 mov	 QWORD PTR [rax], rcx

; 187  : 	}

  00184	e9 56 ff ff ff	 jmp	 $LN2@GetLoadAdd
$LN3@GetLoadAdd:

; 188  : }

  00189	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0018d	c3		 ret	 0
GetLoadAddressRange ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
Status$ = 48
_ImageHandle$ = 80
TransitToKernel PROC

; 138  : )	{

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 139  : 	EFI_STATUS	Status;
; 140  : 
; 141  : 	Status = SystemTable->BootServices->ExitBootServices(_ImageHandle, SystemConfiguration.MemoryInformation.MapKey);

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00010	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00014	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR SystemConfiguration+32
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _ImageHandle$[rsp]
  00020	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]
  00026	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 142  : 
; 143  : 	if (EFI_ERROR(Status)) {

  0002b	48 83 7c 24 30
	00		 cmp	 QWORD PTR Status$[rsp], 0
  00031	0f 8d 81 00 00
	00		 jge	 $LN2@TransitToK

; 144  : 		SystemConfiguration.MemoryInformation.MapSize = sizeof(MemoryMapBuffer);

  00037	48 c7 05 18 00
	00 00 00 28 00
	00		 mov	 QWORD PTR SystemConfiguration+24, 10240 ; 00002800H

; 145  : 
; 146  : 		Status = SystemTable->BootServices->GetMemoryMap(

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00049	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004d	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:SystemConfiguration+48
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	4c 8d 0d 28 00
	00 00		 lea	 r9, OFFSET FLAT:SystemConfiguration+40
  00060	4c 8d 05 20 00
	00 00		 lea	 r8, OFFSET FLAT:SystemConfiguration+32
  00067	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SystemConfiguration+56
  0006e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:SystemConfiguration+24
  00075	ff 50 38	 call	 QWORD PTR [rax+56]
  00078	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 147  : 			&SystemConfiguration.MemoryInformation.MapSize,
; 148  : 			SystemConfiguration.MemoryInformation.MemoryMap,
; 149  : 			&SystemConfiguration.MemoryInformation.MapKey,
; 150  : 			&SystemConfiguration.MemoryInformation.DescriptorSize,
; 151  : 			&SystemConfiguration.MemoryInformation.DescriptorVersion);
; 152  : 
; 153  : 		Status = SystemTable->BootServices->ExitBootServices(_ImageHandle, SystemConfiguration.MemoryInformation.MapKey);

  0007d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00084	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00088	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR SystemConfiguration+32
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _ImageHandle$[rsp]
  00094	ff 90 e8 00 00
	00		 call	 QWORD PTR [rax+232]
  0009a	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 154  : 
; 155  : 		if(EFI_ERROR(Status))	Assert(L"Exiting boot services", Status);

  0009f	48 83 7c 24 30
	00		 cmp	 QWORD PTR Status$[rsp], 0
  000a5	7d 11		 jge	 SHORT $LN3@TransitToK
  000a7	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8029
  000b3	e8 00 00 00 00	 call	 Assert
$LN3@TransitToK:
$LN2@TransitToK:

; 156  : 	}
; 157  : 
; 158  : 	EntryPoint(&SystemConfiguration);

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SystemConfiguration
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR EntryPoint

; 159  : 
; 160  : 	return EFI_SUCCESS;

  000c5	33 c0		 xor	 eax, eax

; 161  : }

  000c7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cb	c3		 ret	 0
TransitToKernel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
Status$ = 48
FileBuffer$ = 56
$S2$ = 64
File$ = 80
FileStartAddress$ = 88
Directory$ = 96
FileSize$ = 104
FileInfoSize$ = 112
FileInfo$ = 120
FileEndAddress$ = 128
NumberOfPages$ = 136
EntryAddress$ = 144
FileInfoBuffer$ = 160
LoadKernel PROC

; 80   : )	{

$LN3:
  00000	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 81   : 	UINTN					FileInfoSize = sizeof(EFI_FILE_INFO) + sizeof(UINT16) * 12;

  00007	48 c7 44 24 70
	70 00 00 00	 mov	 QWORD PTR FileInfoSize$[rsp], 112 ; 00000070H

; 82   : 	UINTN					FileSize;
; 83   : 	UINTN					NumberOfPages;
; 84   : 	EFI_STATUS				Status;
; 85   : 
; 86   : 	EFI_PHYSICAL_ADDRESS	EntryAddress;
; 87   : 	EFI_PHYSICAL_ADDRESS	FileStartAddress;
; 88   : 	EFI_PHYSICAL_ADDRESS	FileEndAddress;
; 89   : 
; 90   : 	UINT8					FileInfoBuffer[sizeof(EFI_FILE_INFO) + sizeof(UINT16) * 12]; // VLA issue; fileInfoSize
; 91   : 	EFI_FILE_INFO*			FileInfo;
; 92   : 
; 93   : 	EFI_FILE_PROTOCOL*		Directory;
; 94   : 	EFI_FILE_PROTOCOL*		File;
; 95   : 	VOID*					FileBuffer;
; 96   : 
; 97   : 	Status = SimpleFileSystemProtocol->OpenVolume(SimpleFileSystemProtocol, &Directory);

  00010	48 8d 54 24 60	 lea	 rdx, QWORD PTR Directory$[rsp]
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SimpleFileSystemProtocol
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SimpleFileSystemProtocol
  00023	ff 50 08	 call	 QWORD PTR [rax+8]
  00026	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 98   : 	Assert(L"Opening root directory", Status);

  0002b	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8011
  00037	e8 00 00 00 00	 call	 Assert

; 99   : 
; 100  : 	Status = Directory->Open(Directory, &File, L"\\Kernel.exe", EFI_FILE_MODE_READ, 0);

  0003c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00045	41 b9 01 00 00
	00		 mov	 r9d, 1
  0004b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG8012
  00052	48 8d 54 24 50	 lea	 rdx, QWORD PTR File$[rsp]
  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR Directory$[rsp]
  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR Directory$[rsp]
  00061	ff 50 08	 call	 QWORD PTR [rax+8]
  00064	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 101  : 	Assert(L"Opening file '\\Kernel.exe'", Status);

  00069	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8013
  00075	e8 00 00 00 00	 call	 Assert

; 102  : 
; 103  : 	Status = File->GetInfo(File, &(EFI_GUID)EFI_FILE_INFO_ID, &FileInfoSize, FileInfoBuffer);

  0007a	c7 44 24 40 92
	6e 57 09	 mov	 DWORD PTR $S2$[rsp], 156724882 ; 09576e92H
  00082	b8 3f 6d 00 00	 mov	 eax, 27967		; 00006d3fH
  00087	66 89 44 24 44	 mov	 WORD PTR $S2$[rsp+4], ax
  0008c	b8 d2 11 00 00	 mov	 eax, 4562		; 000011d2H
  00091	66 89 44 24 46	 mov	 WORD PTR $S2$[rsp+6], ax
  00096	c6 44 24 48 8e	 mov	 BYTE PTR $S2$[rsp+8], 142 ; 0000008eH
  0009b	c6 44 24 49 39	 mov	 BYTE PTR $S2$[rsp+9], 57 ; 00000039H
  000a0	c6 44 24 4a 00	 mov	 BYTE PTR $S2$[rsp+10], 0
  000a5	c6 44 24 4b a0	 mov	 BYTE PTR $S2$[rsp+11], 160 ; 000000a0H
  000aa	c6 44 24 4c c9	 mov	 BYTE PTR $S2$[rsp+12], 201 ; 000000c9H
  000af	c6 44 24 4d 69	 mov	 BYTE PTR $S2$[rsp+13], 105 ; 00000069H
  000b4	c6 44 24 4e 72	 mov	 BYTE PTR $S2$[rsp+14], 114 ; 00000072H
  000b9	c6 44 24 4f 3b	 mov	 BYTE PTR $S2$[rsp+15], 59 ; 0000003bH
  000be	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR FileInfoBuffer$[rsp]
  000c6	4c 8d 44 24 70	 lea	 r8, QWORD PTR FileInfoSize$[rsp]
  000cb	48 8d 54 24 40	 lea	 rdx, QWORD PTR $S2$[rsp]
  000d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR File$[rsp]
  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR File$[rsp]
  000da	ff 50 40	 call	 QWORD PTR [rax+64]
  000dd	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 104  : 	Assert(L"Getting kernel file information", Status);

  000e2	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8014
  000ee	e8 00 00 00 00	 call	 Assert

; 105  : 
; 106  : 	FileInfo = (EFI_FILE_INFO*)FileInfoBuffer;

  000f3	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR FileInfoBuffer$[rsp]
  000fb	48 89 44 24 78	 mov	 QWORD PTR FileInfo$[rsp], rax

; 107  : 
; 108  : 	FileSize = FileInfo->FileSize;

  00100	48 8b 44 24 78	 mov	 rax, QWORD PTR FileInfo$[rsp]
  00105	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00109	48 89 44 24 68	 mov	 QWORD PTR FileSize$[rsp], rax

; 109  : 
; 110  : 	Status = SystemTable->BootServices->AllocatePool(EfiLoaderData, FileSize, &FileBuffer);

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00115	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00119	4c 8d 44 24 38	 lea	 r8, QWORD PTR FileBuffer$[rsp]
  0011e	48 8b 54 24 68	 mov	 rdx, QWORD PTR FileSize$[rsp]
  00123	b9 02 00 00 00	 mov	 ecx, 2
  00128	ff 50 40	 call	 QWORD PTR [rax+64]
  0012b	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 111  : 	Assert(L"Allocating pool", Status);

  00130	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8015
  0013c	e8 00 00 00 00	 call	 Assert

; 112  : 
; 113  : 	Status = File->Read(File, &FileSize, FileBuffer);

  00141	4c 8b 44 24 38	 mov	 r8, QWORD PTR FileBuffer$[rsp]
  00146	48 8d 54 24 68	 lea	 rdx, QWORD PTR FileSize$[rsp]
  0014b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR File$[rsp]
  00150	48 8b 44 24 50	 mov	 rax, QWORD PTR File$[rsp]
  00155	ff 50 20	 call	 QWORD PTR [rax+32]
  00158	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 114  : 	Assert(L"Reading kernel file", Status);

  0015d	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8016
  00169	e8 00 00 00 00	 call	 Assert

; 115  : 
; 116  : 	GetLoadAddressRange(FileBuffer, &FileStartAddress, &FileEndAddress);

  0016e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR FileEndAddress$[rsp]
  00176	48 8d 54 24 58	 lea	 rdx, QWORD PTR FileStartAddress$[rsp]
  0017b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR FileBuffer$[rsp]
  00180	e8 00 00 00 00	 call	 GetLoadAddressRange

; 117  : 
; 118  : 	NumberOfPages = (FileEndAddress - FileStartAddress + 0xfff) / 0x1000;

  00185	48 8b 44 24 58	 mov	 rax, QWORD PTR FileStartAddress$[rsp]
  0018a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR FileEndAddress$[rsp]
  00192	48 2b c8	 sub	 rcx, rax
  00195	48 8b c1	 mov	 rax, rcx
  00198	48 05 ff 0f 00
	00		 add	 rax, 4095		; 00000fffH
  0019e	33 d2		 xor	 edx, edx
  001a0	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  001a5	48 f7 f1	 div	 rcx
  001a8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR NumberOfPages$[rsp], rax

; 119  : 
; 120  : 	Status = SystemTable->BootServices->AllocatePages(AllocateAnyPages, EfiLoaderData, NumberOfPages, &FileStartAddress);

  001b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  001b7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001bb	4c 8d 4c 24 58	 lea	 r9, QWORD PTR FileStartAddress$[rsp]
  001c0	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR NumberOfPages$[rsp]
  001c8	ba 02 00 00 00	 mov	 edx, 2
  001cd	33 c9		 xor	 ecx, ecx
  001cf	ff 50 28	 call	 QWORD PTR [rax+40]
  001d2	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 121  : 	Assert(L"Allocating pages", Status);

  001d7	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8017
  001e3	e8 00 00 00 00	 call	 Assert

; 122  : 
; 123  : 	EntryAddress = *(UINT32*)((INT8*)FileBuffer + 0xE0);

  001e8	48 8b 44 24 38	 mov	 rax, QWORD PTR FileBuffer$[rsp]
  001ed	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [rax+224]
  001f3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR EntryAddress$[rsp], rax

; 124  : 
; 125  : 	EntryPoint = (ENTRY_POINT)(FileStartAddress + EntryAddress);

  001fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR EntryAddress$[rsp]
  00203	48 8b 4c 24 58	 mov	 rcx, QWORD PTR FileStartAddress$[rsp]
  00208	48 03 c8	 add	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	48 89 05 00 00
	00 00		 mov	 QWORD PTR EntryPoint, rax

; 126  : 
; 127  : 	LoadFileSegment(FileBuffer, FileStartAddress);

  00215	48 8b 54 24 58	 mov	 rdx, QWORD PTR FileStartAddress$[rsp]
  0021a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR FileBuffer$[rsp]
  0021f	e8 00 00 00 00	 call	 LoadFileSegment

; 128  : 
; 129  : 	Status = SystemTable->BootServices->FreePool(FileBuffer);

  00224	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  0022b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0022f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR FileBuffer$[rsp]
  00234	ff 50 48	 call	 QWORD PTR [rax+72]
  00237	48 89 44 24 30	 mov	 QWORD PTR Status$[rsp], rax

; 130  : 	Assert(L"Freeing pool", Status);

  0023c	48 8b 54 24 30	 mov	 rdx, QWORD PTR Status$[rsp]
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG8018
  00248	e8 00 00 00 00	 call	 Assert

; 131  : 
; 132  : 	return EFI_SUCCESS;

  0024d	33 c0		 xor	 eax, eax

; 133  : }

  0024f	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00256	c3		 ret	 0
LoadKernel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\User\Documents\개발\운영체제\소스\Boot\Main.c
_TEXT	SEGMENT
tv85 = 48
Index$ = 56
Status$ = 64
$S1$1 = 72
GetSystemConfiguration PROC

; 32   : )	{

$LN13:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 33   : 	UINTN							Index;
; 34   : 	EFI_STATUS						Status;
; 35   : 
; 36   : 	SystemConfiguration.MemoryInformation.MapSize = sizeof(MemoryMapBuffer);

  00004	48 c7 05 18 00
	00 00 00 28 00
	00		 mov	 QWORD PTR SystemConfiguration+24, 10240 ; 00002800H

; 37   : 	SystemConfiguration.MemoryInformation.MemoryMap = MemoryMapBuffer;

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:MemoryMapBuffer
  00016	48 89 05 38 00
	00 00		 mov	 QWORD PTR SystemConfiguration+56, rax

; 38   : 
; 39   : 	Status = SystemTable->BootServices->GetMemoryMap(

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00024	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00028	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:SystemConfiguration+48
  0002f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00034	4c 8d 0d 28 00
	00 00		 lea	 r9, OFFSET FLAT:SystemConfiguration+40
  0003b	4c 8d 05 20 00
	00 00		 lea	 r8, OFFSET FLAT:SystemConfiguration+32
  00042	48 8b 15 38 00
	00 00		 mov	 rdx, QWORD PTR SystemConfiguration+56
  00049	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:SystemConfiguration+24
  00050	ff 50 38	 call	 QWORD PTR [rax+56]
  00053	48 89 44 24 40	 mov	 QWORD PTR Status$[rsp], rax

; 40   : 		&SystemConfiguration.MemoryInformation.MapSize,
; 41   : 		SystemConfiguration.MemoryInformation.MemoryMap,
; 42   : 		&SystemConfiguration.MemoryInformation.MapKey,
; 43   : 		&SystemConfiguration.MemoryInformation.DescriptorSize,
; 44   : 		&SystemConfiguration.MemoryInformation.DescriptorVersion);
; 45   : 
; 46   : 	Assert(L"Getting memory map", Status);

  00058	48 8b 54 24 40	 mov	 rdx, QWORD PTR Status$[rsp]
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7978
  00064	e8 00 00 00 00	 call	 Assert

; 47   : 
; 48   : 	SystemConfiguration.GraphicsInformation.HorizontalResolution = GraphicsOutputProtocol->Mode->Info->HorizontalResolution;

  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GraphicsOutputProtocol
  00070	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007b	89 05 00 00 00
	00		 mov	 DWORD PTR SystemConfiguration, eax

; 49   : 	SystemConfiguration.GraphicsInformation.VerticalResolution = GraphicsOutputProtocol->Mode->Info->VerticalResolution;

  00081	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GraphicsOutputProtocol
  00088	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00093	89 05 04 00 00
	00		 mov	 DWORD PTR SystemConfiguration+4, eax

; 50   : 	SystemConfiguration.GraphicsInformation.Framebuffer = GraphicsOutputProtocol->Mode->FrameBufferBase;

  00099	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GraphicsOutputProtocol
  000a0	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000a8	48 89 05 10 00
	00 00		 mov	 QWORD PTR SystemConfiguration+16, rax

; 51   : 
; 52   : 	switch (GraphicsOutputProtocol->Mode->Info->PixelFormat) {

  000af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR GraphicsOutputProtocol
  000b6	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000ba	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000be	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000c1	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
  000c5	83 7c 24 30 00	 cmp	 DWORD PTR tv85[rsp], 0
  000ca	74 09		 je	 SHORT $LN7@GetSystemC
  000cc	83 7c 24 30 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d1	74 0e		 je	 SHORT $LN8@GetSystemC
  000d3	eb 18		 jmp	 SHORT $LN9@GetSystemC
$LN7@GetSystemC:

; 53   : 		case PixelRedGreenBlueReserved8BitPerColor:
; 54   : 			SystemConfiguration.GraphicsInformation.PixelFormat = PixelRedGreenBlueReserved8BitPerColor;

  000d5	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR SystemConfiguration+8, 0

; 55   : 			break;

  000df	eb 22		 jmp	 SHORT $LN2@GetSystemC
$LN8@GetSystemC:

; 56   : 		case PixelBlueGreenRedReserved8BitPerColor:
; 57   : 			SystemConfiguration.GraphicsInformation.PixelFormat = PixelBlueGreenRedReserved8BitPerColor;

  000e1	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR SystemConfiguration+8, 1

; 58   : 			break;

  000eb	eb 16		 jmp	 SHORT $LN2@GetSystemC
$LN9@GetSystemC:

; 59   : 		default:
; 60   : 			Assert(L"Graphics output protocol does not support RGB Mode", EFI_UNSUPPORTED);

  000ed	48 ba 03 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775805 ; 8000000000000003H
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7982
  000fe	e8 00 00 00 00	 call	 Assert
$LN2@GetSystemC:

; 61   : 	}
; 62   : 
; 63   : 	for (Index = 0; Index < SystemTable->NumberOfTableEntries; ++Index) {

  00103	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR Index$[rsp], 0
  0010c	eb 0d		 jmp	 SHORT $LN6@GetSystemC
$LN4@GetSystemC:
  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR Index$[rsp]
  00113	48 ff c0	 inc	 rax
  00116	48 89 44 24 38	 mov	 QWORD PTR Index$[rsp], rax
$LN6@GetSystemC:
  0011b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SystemTable
  00122	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00126	48 39 44 24 38	 cmp	 QWORD PTR Index$[rsp], rax
  0012b	0f 83 94 00 00
	00		 jae	 $LN5@GetSystemC

; 64   : 		if (CompareGUID(&(EFI_GUID)EFI_ACPI_TABLE_GUID, &SystemTable->ConfigurationTable[Index].VendorGuid) == TRUE) {

  00131	c7 44 24 48 71
	e8 68 88	 mov	 DWORD PTR $S1$1[rsp], -2006390671 ; 8868e871H
  00139	b8 f1 e4 00 00	 mov	 eax, 58609		; 0000e4f1H
  0013e	66 89 44 24 4c	 mov	 WORD PTR $S1$1[rsp+4], ax
  00143	b8 d3 11 00 00	 mov	 eax, 4563		; 000011d3H
  00148	66 89 44 24 4e	 mov	 WORD PTR $S1$1[rsp+6], ax
  0014d	c6 44 24 50 bc	 mov	 BYTE PTR $S1$1[rsp+8], 188 ; 000000bcH
  00152	c6 44 24 51 22	 mov	 BYTE PTR $S1$1[rsp+9], 34 ; 00000022H
  00157	c6 44 24 52 00	 mov	 BYTE PTR $S1$1[rsp+10], 0
  0015c	c6 44 24 53 80	 mov	 BYTE PTR $S1$1[rsp+11], 128 ; 00000080H
  00161	c6 44 24 54 c7	 mov	 BYTE PTR $S1$1[rsp+12], 199 ; 000000c7H
  00166	c6 44 24 55 3c	 mov	 BYTE PTR $S1$1[rsp+13], 60 ; 0000003cH
  0016b	c6 44 24 56 88	 mov	 BYTE PTR $S1$1[rsp+14], 136 ; 00000088H
  00170	c6 44 24 57 81	 mov	 BYTE PTR $S1$1[rsp+15], 129 ; 00000081H
  00175	48 6b 44 24 38
	18		 imul	 rax, QWORD PTR Index$[rsp], 24
  0017b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SystemTable
  00182	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00186	48 03 c8	 add	 rcx, rax
  00189	48 8b c1	 mov	 rax, rcx
  0018c	48 8b d0	 mov	 rdx, rax
  0018f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $S1$1[rsp]
  00194	e8 00 00 00 00	 call	 CompareGUID
  00199	0f b6 c0	 movzx	 eax, al
  0019c	83 f8 01	 cmp	 eax, 1
  0019f	75 1f		 jne	 SHORT $LN10@GetSystemC

; 65   : 			SystemConfiguration.ACPIInformation = (ROOT_SYSTEM_DESCRIPTOR_POINTER*)SystemTable->ConfigurationTable[Index].VendorTable;

  001a1	48 6b 44 24 38
	18		 imul	 rax, QWORD PTR Index$[rsp], 24
  001a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SystemTable
  001ae	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001b2	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  001b7	48 89 05 40 00
	00 00		 mov	 QWORD PTR SystemConfiguration+64, rax

; 66   : 			break;

  001be	eb 05		 jmp	 SHORT $LN5@GetSystemC
$LN10@GetSystemC:

; 67   : 		}
; 68   : 	}

  001c0	e9 49 ff ff ff	 jmp	 $LN4@GetSystemC
$LN5@GetSystemC:

; 69   : 
; 70   : 	if (SystemConfiguration.ACPIInformation == NULL) {

  001c5	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR SystemConfiguration+64, 0
  001cd	75 16		 jne	 SHORT $LN11@GetSystemC

; 71   : 		Assert(L"Founding ACPI Table", EFI_NOT_FOUND);

  001cf	48 ba 0e 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775794 ; 800000000000000eH
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG7985
  001e0	e8 00 00 00 00	 call	 Assert
$LN11@GetSystemC:

; 72   : 	}
; 73   : 
; 74   : 	return EFI_SUCCESS;

  001e5	33 c0		 xor	 eax, eax

; 75   : }

  001e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001eb	c3		 ret	 0
GetSystemConfiguration ENDP
_TEXT	ENDS
END
